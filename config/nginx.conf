# Events block
events {
    worker_connections 1024;  # Defines the maximum number of simultaneous connections
}

# HTTP block
http {
    # Required modules for Lua scripting
    lua_shared_dict rate_limit_store 10m;  # Shared memory for rate-limiting data

    upstream flask_servers {
        server 127.0.0.1:5001;
        server 127.0.0.1:5002;
        server 127.0.0.1:5003;
    }

    server {
        listen 80;

        location / {
            # Rate-limiting logic
            access_by_lua_block {
                local limit_key = ngx.var.binary_remote_addr  -- Use client IP for rate-limiting key
                local rate_limit_store = ngx.shared.rate_limit_store
                local max_attempts = 5  -- Maximum retry attempts
                local base_delay = 0.5  -- Base delay (in seconds) for exponential backoff
                local jitter = 0.2      -- Jitter (random variance in seconds)

                -- Fetch request count for the client
                local attempts = rate_limit_store:get(limit_key) or 0

                -- If the limit is exceeded, apply exponential backoff with jitter
                if attempts >= max_attempts then
                    local delay = base_delay * (2 ^ (attempts - max_attempts)) + math.random() * jitter
                    ngx.sleep(delay)
                    ngx.log(ngx.WARN, "Delaying request for ", delay, " seconds for client ", limit_key)
                end

                -- Increment attempts and set expiration for the key
                rate_limit_store:incr(limit_key, 1)
                if attempts == 0 then
                    rate_limit_store:set(limit_key, 1, 60)  -- Reset counter after 60 seconds
                end
            }

            # Forward request to Flask app
            proxy_pass http://flask_servers;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
            proxy_set_header Content-Length $content_length;

            # Forwarding the body of the request (POST/PUT)
            proxy_pass_request_body on;
            proxy_set_header Content-Length "";
        }

        # Route for /hello
        location /hello {
            default_type text/plain;  # Set content type to plain text
            return 200 "Hello, World!\n";  # Return "Hello, World!" with status 200
        }

        location /fetch {
            proxy_pass http://flask_servers;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        location /insert {
            proxy_pass http://flask_servers;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
}
